{
    "collab_server" : "",
    "contents" : "#' Find the limits of a Stars density distributions\n#'\n#'\n#' @details\n#' Splits the dataframe of a \\code{Star} into its constituent beams (identified by their \"BeamId\").\n#' Each beams \\code{UrbanLayerName} column is then evaluated to find a plausible segmentation point, which can be considered the urban limit.\n#' The criterium for the point being: First point at which\n#' \\enumerate{\n#' \\item the value is lower than \\code{\"Threshold\"} and\n#' \\item the mean slope over the next \\code{SlopeWindow} data points is lower than \\code{SlopeThreshold}\n#' }\n#' The limits are then used to create a logical vector of \\code{length(Star)}, indicating for each segment of the Star whether it is urban.\n#' If for at least one of the beams, no point satisfies both conditions, NA is returned.\n#'\n#'\n#' @param Star a Star object that contains columns \"BeamId\" and \"SegmentId\", as created by create_star()\n#' @param UrbanLayerName the name of the column which holds the density values\n#' @param Threshold a threshold under which the density is considered nonurban\n#' @param SlopeWindow a forward looking search window in which the mean slope is evaluated\n#' @param SlopeThreshold the threshold under which the in SlopeWindow calculated mean of the slope is considered to be small\n#'\n#' @return Logical vector\n#'\n#' @examples\n#' find_limit_star(Star,UrbanLayerName,Threshold=50,SlopeThreshold=0.01,SlopeWindow=3)\n#'\n#'\n#' @seealso\n#' \\code{\\link{find_limit}},\n#' \\code{\\link{split_star_into_beams}}\n#'\n#' @export\n#' @import sp\n#' @author Johannes Mast\n\n\n\n#This function provides the added convenience of directly finding the limits of a star object\n# By splitting it first and then applying the find_limit function on its components\nfind_limit_star <- function(Star,UrbanLayerName,Threshold=50,SlopeThreshold=0.01,SlopeWindow=3){\n  StarDataByBeams <- split_star_into_beams(Star)\n  Limits <- unlist(lapply(StarDataByBeams,function(x) (find_limit(x[[UrbanLayerName]],Threshold = Threshold,SlopeThreshold = SlopeThreshold,SlopeWindow = SlopeWindow))))\n  if(anyNA(Limits)){ ##If For one of the beams no limit was found, return NA as an error indicator\n\n    return(NA)\n  }else{ ##Else continue as usual\n    # Create a logical vector for the star elements that determines if they are urban or not (Error prone for unknown reasons)\n    IsUrban <- apply(Star@data,MARGIN = 1, FUN = function(x){x[\"SegmentId\"]<Limits[as.integer(x[\"BeamId\"])]})\n\n    # Create a logical vector for the star elements that determines if they are urban or not\n    # Should do the same thing as the apply function above, but is not bugged\n    IsUrban <- vector(length=length(Star))\n\n    for (i in 1:length(Star)){\n      IsUrban[i] <- Star$SegmentId[i]<=Limits[Star$BeamId[i]]\n    }\n    return(IsUrban)\n  }\n}\n",
    "created" : 1548515737498.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1735302357",
    "id" : "6019A85E",
    "lastKnownWriteTime" : 1548515755,
    "last_content_update" : 1548515755678,
    "path" : "~/Studiendateien/R_Scripts/UrbanStars/R/find_limit_star.R",
    "project_path" : "R/find_limit_star.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}